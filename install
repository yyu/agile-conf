#!/usr/bin/env python3

import argparse
import os
import sys
import time
import urllib.request
import subprocess

from typing import Dict


class Color:

    @staticmethod
    def red(s): return '\033[31m' + s + '\033[0m'

    @staticmethod
    def green(s): return '\033[32m' + s + '\033[0m'

    @staticmethod
    def yellow(s): return '\033[33m' + s + '\033[0m'

    @staticmethod
    def blue(s): return '\033[34m' + s + '\033[0m'

    @staticmethod
    def magenta(s): return '\033[35m' + s + '\033[0m'

    @staticmethod
    def cyan(s): return '\033[36m' + s + '\033[0m'

    @staticmethod
    def gray(s): return '\033[37m' + s + '\033[0m'


def make_full_path(path: str) -> str:
    return os.path.expanduser(path)


def make_dir_as_needed(path: str) -> None:
    folder = os.path.dirname(path)
    os.makedirs(folder, exist_ok=True)


def shell_run(cmd: str) -> int:
    print(Color.gray(f'> {cmd}'))
    return subprocess.check_call(cmd, shell=True)


def add_to_bashrc(rc_path: str) -> None:
    shell_run('echo >> ~/.bashrc')
    shell_run('echo "# added by my-bash/install" >> ~/.bashrc')
    shell_run(f'echo ". {rc_path}" >> ~/.bashrc')


def backup(file: str) -> str:
    full_path = make_full_path(file)
    existing_file = None
    if os.path.exists(full_path):
        existing_file = f'{full_path}-{time.time()}'
        shell_run(f'/bin/mv {full_path} {existing_file}')
    return existing_file


def prepend_to_vimrc(rc_path: str, vimrc_path: str) -> None:
    existing_vimrc = backup(vimrc_path)
    shell_run(f': > {vimrc_path}')
    append_to_vimrc(rc_path, vimrc_path)
    if existing_vimrc:
        shell_run(f'echo "\\" {existing_vimrc} is pasted below" >> {vimrc_path}')
        shell_run(f'cat {existing_vimrc} >> {vimrc_path}')


def append_to_vimrc(rc_path: str, vimrc_path: str) -> None:
    shell_run(f'echo """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" >> {vimrc_path}')
    shell_run(f'echo "\\" added by my-bash/install" >> {vimrc_path}')
    shell_run(f'echo "source {rc_path}" >> {vimrc_path}')
    shell_run(f'echo """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" >> {vimrc_path}')


def add_to_vimrc(rc_path: str) -> None:
    append_to_vimrc(rc_path, '~/.vimrc')


def setup_vundle(rc_path: str) -> None:
    prepend_to_vimrc(rc_path, '~/.vimrc')
    install_vundle_plugins()


def install_vundle_plugins():
    vundle_path = '~/.vim/bundle/Vundle.vim'
    backup(os.path.dirname(vundle_path))
    shell_run(f'git clone https://github.com/VundleVim/Vundle.vim.git {vundle_path}')
    shell_run('vim +PluginInstall +qall')


class Rc:
    def __init__(self, url: str, local_path: str,
                 post_download_func=lambda rc_path: print('no post-download procedure')):
        self.local_path = local_path
        self.local_full_path = make_full_path(local_path)
        self.url = url
        self.post_download = post_download_func

    def download(self) -> None:
        make_dir_as_needed(self.local_full_path)

        with open(self.local_full_path, 'wt') as f:
            response = urllib.request.urlopen(self.url)
            f.write(response.read().decode())

    def install(self) -> None:
        print('%s <== %s' % (self.local_full_path, self.url))
        self.download()
        self.post_download(self.local_path)


def parse_args() -> (str, str):
    arg_parser = argparse.ArgumentParser()

    arg_parser.add_argument(dest='urls', metavar='url', nargs='*')
    arg_parser.add_argument('-o', dest='folder', action='store', help='folder for the downloaded content')

    arguments = arg_parser.parse_args()

    return arguments.folder, arguments.urls


def make_url_map() -> Dict[str, str]:
    """ parse the command line arguments and build a url->filepath map. url will be downloaded and saved as filepath

    :return: the url->filepath map
    """
    install_folder, urls = parse_args()

    if not install_folder:
        install_folder = '~/.my-bash'

    if not urls:
        default_url_prefix = 'https://raw.githubusercontent.com/yyu/my-bash/master'
        urls = [
            # for .bashrc
            os.path.join(default_url_prefix, 'termcolors.bashrc'),
            os.path.join(default_url_prefix, 'terminal_prompt.bashrc'),
            os.path.join(default_url_prefix, 'aliases.bashrc'),
            # for .vimrc
            os.path.join(default_url_prefix, 'vim_plugins.vundle'),
            os.path.join(default_url_prefix, 'syntax.vimrc'),
            os.path.join(default_url_prefix, 'cursor.vimrc'),
            os.path.join(default_url_prefix, 'files.vimrc'),
            os.path.join(default_url_prefix, 'more.vimrc'),
        ]

    return {url: os.path.join(install_folder, os.path.basename(url)) for url in urls}


def standard_post_download(rc_path: str) -> None:
    post_download_func_map = {
        '.bashrc': add_to_bashrc,
        '.vundle': setup_vundle,
        '.vimrc': add_to_vimrc
    }

    _, ext = os.path.splitext(rc_path)
    post_download_func_map[ext](rc_path)


if __name__ == '__main__':
    url_map = make_url_map()

    rc_list = [Rc(url, local_path, standard_post_download) for (url, local_path) in url_map.items()]

    for rc in rc_list:
        rc.install()

    print(Color.green('\na new bash session is good for your health'), file=sys.stderr)
